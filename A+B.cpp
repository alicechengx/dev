/*
一般来说，不给用+ - 的话大多是位运算，如果不给*/的话大多使用+-来实现
好吧 那就位运算吧。

这个位运算的关键在于异或^操作。
附上真值表
1 0 -> 1
0 0 -> 0
1 1 -> 0
0 1 -> 1

如果异或2个二进制数，实际上就是对这两个数做了 “不完全加法”。
这里的不完全指的是“不进位”。
比如说：10 ^ 11 = 01
而          10 + 11 = 101
仔细分析观察一下可以看出其实差别在于 异或操作相比于直接+缺少了每一位的进位 而且它值都是一样的

附上加法“真值表”
1 0 -> 1
0 0 -> 0
1 1 -> 0 (carry 1)
0 1 -> 1

但是怎么解决进位的问题呢？我们先看看10进制
275 + 197 = 472
我们先用“不完全加法”来计算一下
275 +(不进位) 197 = 362

好的，那我们再看看需要进位的操作
首先，第一位5+7 = 12
第二位9+7 = 16
这有两个进位点
由于，进位的数都加在左移的一位，所以本来是 11，左移一下，变成了110
也就是 275 + 197 = 275 +(不进位) 197 + (11 << 1) = 362 + 110 = 472

OK 现在我们知道该如何处理进位的事情了。可是照以上的思路，这个不完全加法和进位数值到最后不还是要依赖于相加的运算得出最后结果么？
于是我们想到了递归！因为总会有一个base case可以消除相加的必要！
没错，就是进位值为0的时候，我们的“不完全加法”就变成了完全加法。
plus(275, 197) -> plus(362, 110) -> plus(472, 0) -> 472+0其实就可以返回472了！
*/


class Solution {
public:
    /**
     * @param a: An integer
     * @param b: An integer
     * @return: The sum of a and b 
     */
    int helper(int a, int b)
    {
        if (b==0)
            return a;
        else
            return helper(a^b, (a&b) <<1);
    }
    int aplusb(int a, int b) {
        // write your code here
       return helper(a, b);
    }
};
